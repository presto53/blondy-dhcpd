# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# Require this file using `require "spec_helper"` to ensure that it is only
# loaded once.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
require 'simplecov'
SimpleCov.start

require 'net-dhcp'
require 'eventmachine'
require 'em-http'
require 'ostruct'
require 'ipaddr'
require 'rspec'
require 'webmock/rspec'
require 'json'
require 'fiber'

spec_root = File.dirname(File.absolute_path(__FILE__))
Dir.glob(spec_root + '/../lib/blondy/dhcpd/*') {|file| require file}

# Set config for test
Blondy::DHCPD::CONFIG = Hash.new
Blondy::DHCPD::CONFIG['server_ip'] = '192.168.5.1'
Blondy::DHCPD::CONFIG['master'] = 'https://127.0.0.1/blondy/dhcpd'
Blondy::DHCPD::CONFIG['client_key'] = 'abcd'
Logger = Log4r::Logger.new 'ruby-dhcpd'

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = 'random'
end

# Wrap for running examples inside eventmachine reactor
RSpec::Core::Example.class_eval do
  alias ignorant_run run
  class << self
    attr_accessor :examples_fibers
  end 
  self.examples_fibers = Array.new

  def run(example_group_instance, reporter)
    if @options[:no_em]
      fibers_alive = [true]
      while fibers_alive.include?(true)
	fibers_alive = []
	self.class.examples_fibers.each do |f| 
	  f.resume if f.alive?
	  fibers_alive << f.alive?
	end
      end 
      while EM.reactor_running?
	EM.stop
	sleep 0.5 
      end 
      ignorant_run example_group_instance, reporter
    elsif @options[:no_fiber]
      EM.run do
	df = EM::DefaultDeferrable.new
	result = nil
	df.callback { |x| EM.stop_event_loop; result }
	result = ignorant_run example_group_instance, reporter
	df.succeed
      end
    else
      f = Fiber.new do
	EM.run do
	  df = EM::DefaultDeferrable.new
	  result = nil 
	  df.callback { |x| EM.stop_event_loop; Fiber.yield result }
	  result = ignorant_run example_group_instance, reporter
	  df.succeed
	end
      end 
      self.class.examples_fibers << f
      f.resume
    end 
  end
end
